---
layout: post
title:  "[RITSEC CTF 21] Un-machined Aerial System"
date:   "2021-04-12"
categories: Reverse
author: eurus
---

we have an elf file. By disassembling it we have that:

```assembly
.text:18C2     lea     rdi, format     ; "Fill in the rest of the flag: RS{"
.text:18C9     mov     eax, 0
.text:18CE     call    _printf
.text:18D3     mov     rdx, cs:stdin   ; stream
.text:18DA     lea     rax, [rbp+s]
.text:18DE     mov     esi, 14h        ; n
.text:18E3     mov     rdi, rax        ; s
.text:18E6     call    _fgets
.text:18EB     lea     rax, [rbp+s]
.text:18EF     lea     rsi, reject     ; "\n"
.text:18F6     mov     rdi, rax        ; s
.text:18F9     call    _strcspn
.text:18FE     mov     [rbp+rax+s], 0
.text:1903     lea     rax, [rbp+s]
.text:1907     mov     rsi, rax
.text:190A     lea     rdi, aTheInputtedFla ; "The inputted flag was RS{%s}"
.text:1911     mov     eax, 0
.text:1916     call    _printf
```

we can see that at ``` 0x18e6 ``` the program take as input ``` 0x14 ``` bytes. The bytes that we give as input represent the flag and after we have:

```assembly
.text:199A     lea     rdi, aYayYouGotTheFl ; "YAY, you got the flag!"
.text:19A1     call    _puts
.text:19A6     jmp     short loc_19B4
.text:19A8 ; ------------------------------------------------------------
.text:19A8
.text:19A8  loc_19A8:                  ; CODE XREF: main+14Dâ†‘j
.text:19A8     lea     rdi, aSorryThatSNotT ;"Sorry, that's not the flag..."
.text:19AF     call    _puts
```

In this month I have been studing angr and in this challenge, and whit angr this challenge seems very easy.

First I need to declare the input value that I give to the binary program as BVS

```python
input_len = 20

flag_chars = [claripy.BVS(f'flag_{i}',8) for i in range(input_len)]
flag = claripy.Concat( *flag_chars + [claripy.BVV(b'\n')] )
```

and then I add some costraint to this BVSs for lock the possible value as printable character.

```python
for c in flag_chars:
        st.solver.add(c < 0x7f )
        st.solver.add(c > 0x20 )
```

st was declared here. sm is a Simstate.
In [angr doc site](https://docs.angr.io/core-concepts/toplevel):
> A SimState contains a program's memory, registers, filesystem data... 
> any "live data" that can be changed by execution has a home in the state. 



